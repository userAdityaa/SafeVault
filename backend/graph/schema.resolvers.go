package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/useradityaa/graph/model"
	"github.com/useradityaa/internal/middleware"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.AuthPayload, error) {
	user, token, err := r.AuthService.Signup(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:    user.ID.String(),
			Email: user.Email,
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, token, err := r.AuthService.Login(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:    user.ID.String(),
			Email: user.Email,
		},
	}, nil
}

// GoogleLogin is the resolver for the googleLogin field.
func (r *mutationResolver) GoogleLogin(ctx context.Context, input model.GoogleLoginInput) (*model.AuthPayload, error) {
	user, token, err := r.GoogleService.LoginWithGoogle(ctx, input.IDToken)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:    user.ID.String(),
			Email: user.Email,
		},
	}, nil
}

// UploadFiles is the resolver for the uploadFiles field.
func (r *mutationResolver) UploadFiles(ctx context.Context, input model.UploadFileInput) ([]*model.UserFile, error) {
	// Require authentication
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}

	// Convert GraphQL uploads to the type FileService expects
	var uploads []*graphql.Upload
	for _, up := range input.Files {
		if up == nil || up.File == nil {
			return nil, fmt.Errorf("invalid file input")
		}
		uploads = append(uploads, up)
	}

	if r.FileService == nil {
		return nil, fmt.Errorf("file storage not configured")
	}

	userFiles, err := r.FileService.UploadFiles(ctx, userID, uploads)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL models
	var gqlFiles []*model.UserFile
	for _, uf := range userFiles {
		gqlFiles = append(gqlFiles, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
		})
	}

	return gqlFiles, nil
}

// Health is the resolver for the _health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "ok", nil
}

// MyFiles is the resolver for the myFiles field.
func (r *queryResolver) MyFiles(ctx context.Context) ([]*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	ufs, err := r.FileService.GetUserFiles(ctx, userID)
	if err != nil {
		return nil, err
	}
	var out []*model.UserFile
	for _, uf := range ufs {
		out = append(out, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
		})
	}
	return out, nil
}

// MyStorage is the resolver for the myStorage field.
func (r *queryResolver) MyStorage(ctx context.Context) (*model.StorageUsage, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	used, quota, err := r.FileService.GetUserUsage(ctx, userID)
	if err != nil {
		return nil, err
	}
	percent := float64(0)
	if quota > 0 {
		percent = (float64(used) / float64(quota)) * 100.0
	}
	return &model.StorageUsage{
		UsedBytes:   int(used),
		QuotaBytes:  int(quota),
		PercentUsed: percent,
	}, nil
}

// FindMyFileByHash is the resolver for the findMyFileByHash field.
func (r *queryResolver) FindMyFileByHash(ctx context.Context, hash string) (*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	uf, err := r.FileService.FindUserFileByHash(ctx, userID, hash)
	if err != nil {
		return nil, err
	}
	if uf == nil {
		return nil, nil
	}
	return &model.UserFile{
		ID:         uf.ID.String(),
		UserID:     uf.UserID.String(),
		FileID:     uf.FileID.String(),
		UploadedAt: uf.UploadedAt.Format(time.RFC3339),
		File: &model.File{
			ID:           uf.File.ID.String(),
			Hash:         uf.File.Hash,
			OriginalName: uf.File.OriginalName,
			MimeType:     uf.File.MimeType,
			Size:         int(uf.File.Size),
			Visibility:   uf.File.Visibility,
			CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
		},
	}, nil
}

// FileURL is the resolver for the fileURL field.
func (r *queryResolver) FileURL(ctx context.Context, fileID string, inline *bool) (string, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return "", fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return "", fmt.Errorf("invalid user id in token")
	}
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return "", fmt.Errorf("invalid file id")
	}
	in := false
	if inline != nil {
		in = *inline
	}
	if r.FileService == nil {
		return "", fmt.Errorf("file service not configured")
	}
	return r.FileService.GetFileURL(ctx, userID, fid, in)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
