package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"
	"net/url"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/useradityaa/graph/model"
	"github.com/useradityaa/internal/middleware"
	"github.com/useradityaa/internal/repository"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.AuthPayload, error) {
	user, token, err := r.AuthService.Signup(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:      user.ID.String(),
			Email:   user.Email,
			IsAdmin: r.AuthService.IsAdmin(user.Email),
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, token, err := r.AuthService.Login(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:      user.ID.String(),
			Email:   user.Email,
			IsAdmin: r.AuthService.IsAdmin(user.Email),
		},
	}, nil
}

// GoogleLogin is the resolver for the googleLogin field.
func (r *mutationResolver) GoogleLogin(ctx context.Context, input model.GoogleLoginInput) (*model.AuthPayload, error) {
	user, token, err := r.GoogleService.LoginWithGoogle(ctx, input.IDToken)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:      user.ID.String(),
			Email:   user.Email,
			Name:    &user.Name,
			Picture: &user.Picture,
			IsAdmin: r.AuthService.IsAdmin(user.Email),
		},
	}, nil
}

// UploadFiles is the resolver for the uploadFiles field.
func (r *mutationResolver) UploadFiles(ctx context.Context, input model.UploadFileInput) ([]*model.UserFile, error) {
	// Require authentication
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}

	// Convert GraphQL uploads to the type FileService expects
	var uploads []*graphql.Upload
	for _, up := range input.Files {
		if up == nil || up.File == nil {
			return nil, fmt.Errorf("invalid file input")
		}
		uploads = append(uploads, up)
	}

	if r.FileService == nil {
		return nil, fmt.Errorf("file storage not configured")
	}

	// Pass allowDuplicate down via context for now (small change without altering service signature)
	if input.AllowDuplicate != nil && *input.AllowDuplicate {
		ctx = context.WithValue(ctx, struct{ key string }{"allowDuplicate"}, true)
	}
	userFiles, err := r.FileService.UploadFiles(ctx, userID, uploads)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL models
	var gqlFiles []*model.UserFile
	for _, uf := range userFiles {
		// Inline pointer construction for optional fields
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		gqlFiles = append(gqlFiles, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				RefCount:     uf.File.RefCount,
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{
				Email:   uf.UploaderEmail,
				Name:    namePtr,
				Picture: picPtr,
			},
		})
	}

	return gqlFiles, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file id")
	}
	if r.FileService == nil {
		return false, fmt.Errorf("file service not configured")
	}
	if err := r.FileService.SoftDeleteUserFile(ctx, userID, fid); err != nil {
		return false, err
	}
	return true, nil
}

// PurgeFile is the resolver for the purgeFile field.
func (r *mutationResolver) PurgeFile(ctx context.Context, fileID string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file id")
	}
	if r.FileService == nil {
		return false, fmt.Errorf("file service not configured")
	}
	if err := r.FileService.PurgeUserFile(ctx, userID, fid); err != nil {
		return false, err
	}
	return true, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, name string, parentID *string) (*model.Folder, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FolderService == nil {
		return nil, fmt.Errorf("folder service not configured")
	}
	var pid *uuid.UUID
	if parentID != nil && *parentID != "" {
		id, err := uuid.Parse(*parentID)
		if err != nil {
			return nil, fmt.Errorf("invalid parent id")
		}
		pid = &id
	}
	id, err := r.FolderService.CreateFolder(ctx, userID, name, pid)
	if err != nil {
		return nil, err
	}
	// Load created folder
	// We don't have a direct getter in service; return minimal payload
	now := time.Now().Format(time.RFC3339)
	var pidStr *string
	if pid != nil {
		s := pid.String()
		pidStr = &s
	}
	return &model.Folder{ID: id.String(), Name: name, ParentID: pidStr, CreatedAt: now}, nil
}

// RenameFolder is the resolver for the renameFolder field.
func (r *mutationResolver) RenameFolder(ctx context.Context, folderID string, newName string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	if r.FolderService == nil {
		return false, fmt.Errorf("folder service not configured")
	}
	fid, err := uuid.Parse(folderID)
	if err != nil {
		return false, fmt.Errorf("invalid folder id")
	}
	if err := r.FolderService.RenameFolder(ctx, userID, fid, newName); err != nil {
		return false, err
	}
	return true, nil
}

// DeleteFolder is the resolver for the deleteFolder field.
func (r *mutationResolver) DeleteFolder(ctx context.Context, folderID string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	if r.FolderService == nil {
		return false, fmt.Errorf("folder service not configured")
	}
	fid, err := uuid.Parse(folderID)
	if err != nil {
		return false, fmt.Errorf("invalid folder id")
	}
	if err := r.FolderService.DeleteFolder(ctx, userID, fid); err != nil {
		return false, err
	}
	return true, nil
}

// MoveUserFile is the resolver for the moveUserFile field.
func (r *mutationResolver) MoveUserFile(ctx context.Context, mappingID string, folderID *string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return false, fmt.Errorf("file service not configured")
	}
	mid, err := uuid.Parse(mappingID)
	if err != nil {
		return false, fmt.Errorf("invalid mapping id")
	}
	var fid *uuid.UUID
	if folderID != nil && *folderID != "" {
		id, err := uuid.Parse(*folderID)
		if err != nil {
			return false, fmt.Errorf("invalid folder id")
		}
		fid = &id
	}
	if err := r.FileService.FileRepo.MoveUserFileToFolder(ctx, userID, mid, fid); err != nil {
		return false, err
	}
	return true, nil
}

// ShareFile is the resolver for the shareFile field.
func (r *mutationResolver) ShareFile(ctx context.Context, input model.ShareFileInput) (*model.FileShare, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	fileID, err := uuid.Parse(input.FileID)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID")
	}

	var expiresAt *time.Time
	if input.ExpiresAt != nil {
		parsedTime, err := time.Parse(time.RFC3339, *input.ExpiresAt)
		if err != nil {
			return nil, fmt.Errorf("invalid expires_at format")
		}
		expiresAt = &parsedTime
	}

	shares, err := r.ShareService.ShareFile(ctx, userID, fileID, input.Emails, input.Permission, expiresAt)
	if err != nil {
		return nil, err
	}

	if len(shares) == 0 {
		return nil, fmt.Errorf("failed to create share")
	}

	// Return the first share created
	share := shares[0]
	return &model.FileShare{
		ID:              share.ID.String(),
		FileID:          share.FileID.String(),
		OwnerID:         share.OwnerID.String(),
		SharedWithEmail: share.SharedWithEmail,
		Permission:      share.Permission,
		SharedAt:        share.SharedAt.Format(time.RFC3339),
	}, nil
}

// ShareFolder is the resolver for the shareFolder field.
func (r *mutationResolver) ShareFolder(ctx context.Context, input model.ShareFolderInput) (*model.FolderShare, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	folderID, err := uuid.Parse(input.FolderID)
	if err != nil {
		return nil, fmt.Errorf("invalid folder ID")
	}

	var expiresAt *time.Time
	if input.ExpiresAt != nil {
		t, err := time.Parse(time.RFC3339, *input.ExpiresAt)
		if err != nil {
			return nil, fmt.Errorf("invalid expiration date")
		}
		expiresAt = &t
	}

	shares, err := r.ShareService.ShareFolder(ctx, userID, folderID, input.Emails, input.Permission, expiresAt)
	if err != nil {
		return nil, err
	}

	if len(shares) == 0 {
		return nil, fmt.Errorf("no shares created")
	}

	// Return the first share (representing the successful operation)
	share := shares[0]
	return &model.FolderShare{
		ID:              share.ID.String(),
		FolderID:        share.FolderID.String(),
		OwnerID:         share.OwnerID.String(),
		SharedWithEmail: share.SharedWithEmail,
		Permission:      share.Permission,
		SharedAt:        share.SharedAt.Format(time.RFC3339),
	}, nil
}

// UnshareFile is the resolver for the unshareFile field.
func (r *mutationResolver) UnshareFile(ctx context.Context, fileID string, sharedWithEmail string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user ID")
	}

	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file ID")
	}

	err = r.ShareService.UnshareFile(ctx, userID, fileUUID, sharedWithEmail)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UnshareFolder is the resolver for the unshareFolder field.
func (r *mutationResolver) UnshareFolder(ctx context.Context, folderID string, sharedWithEmail string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user ID")
	}

	folderUUID, err := uuid.Parse(folderID)
	if err != nil {
		return false, fmt.Errorf("invalid folder ID")
	}

	err = r.ShareService.UnshareFolder(ctx, userID, folderUUID, sharedWithEmail)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CreatePublicFileLink is the resolver for the createPublicFileLink field.
func (r *mutationResolver) CreatePublicFileLink(ctx context.Context, fileID string, expiresAt *string) (*model.PublicFileLink, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}
	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID")
	}
	var expPtr *time.Time
	if expiresAt != nil && *expiresAt != "" {
		t, err := time.Parse(time.RFC3339, *expiresAt)
		if err != nil {
			return nil, fmt.Errorf("invalid expiresAt format; must be RFC3339")
		}
		expPtr = &t
	}
	if r.PublicLinkService == nil {
		return nil, fmt.Errorf("public link service not configured")
	}
	token, exp, err := r.PublicLinkService.CreateFileLink(ctx, userID, fileUUID, expPtr)
	if err != nil {
		return nil, err
	}
	// Try to fetch active link to obtain created_at / revoked_at if needed (best-effort)
	var createdAt = time.Now().Format(time.RFC3339)
	// repository GetActiveFileLinkByFile returns (token, expiresAt, revokedAt)
	if tkn, exp2, revoked, e2 := r.PublicLinkService.PublicRepo.GetActiveFileLinkByFile(ctx, fileUUID); e2 == nil && tkn == token {
		if exp2 != nil {
			exp = exp2
		}
		if revoked != nil { /* active link shouldn't be revoked, ignore */
		}
	}
	var expStr *string
	if exp != nil {
		s := exp.Format(time.RFC3339)
		expStr = &s
	}
	return &model.PublicFileLink{
		FileID:    fileID,
		Token:     token,
		URL:       fmt.Sprintf("/share/%s", token),
		CreatedAt: createdAt,
		ExpiresAt: expStr,
	}, nil
}

// RevokePublicFileLink is the resolver for the revokePublicFileLink field.
func (r *mutationResolver) RevokePublicFileLink(ctx context.Context, fileID string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user ID")
	}
	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file ID")
	}
	if r.PublicLinkService == nil {
		return false, fmt.Errorf("public link service not configured")
	}
	if err := r.PublicLinkService.RevokeFileLink(ctx, userID, fileUUID); err != nil {
		return false, err
	}
	return true, nil
}

// CreatePublicFolderLink is the resolver for the createPublicFolderLink field.
func (r *mutationResolver) CreatePublicFolderLink(ctx context.Context, folderID string, expiresAt *string) (*model.PublicFolderLink, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}
	folderUUID, err := uuid.Parse(folderID)
	if err != nil {
		return nil, fmt.Errorf("invalid folder ID")
	}
	var expPtr *time.Time
	if expiresAt != nil && *expiresAt != "" {
		t, err := time.Parse(time.RFC3339, *expiresAt)
		if err != nil {
			return nil, fmt.Errorf("invalid expiresAt format; must be RFC3339")
		}
		expPtr = &t
	}
	if r.PublicLinkService == nil {
		return nil, fmt.Errorf("public link service not configured")
	}
	token, exp, err := r.PublicLinkService.CreateFolderLink(ctx, userID, folderUUID, expPtr)
	if err != nil {
		return nil, err
	}
	var createdAt = time.Now().Format(time.RFC3339)
	if tkn, exp2, revoked, e2 := r.PublicLinkService.PublicRepo.GetActiveFolderLinkByFolder(ctx, folderUUID); e2 == nil && tkn == token {
		if exp2 != nil {
			exp = exp2
		}
		if revoked != nil { /* ignore revoked sanity */
		}
	}
	var expStr *string
	if exp != nil {
		s := exp.Format(time.RFC3339)
		expStr = &s
	}
	return &model.PublicFolderLink{
		FolderID:  folderID,
		Token:     token,
		URL:       fmt.Sprintf("/share/%s", token),
		CreatedAt: createdAt,
		ExpiresAt: expStr,
	}, nil
}

// RevokePublicFolderLink is the resolver for the revokePublicFolderLink field.
func (r *mutationResolver) RevokePublicFolderLink(ctx context.Context, folderID string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user ID")
	}
	folderUUID, err := uuid.Parse(folderID)
	if err != nil {
		return false, fmt.Errorf("invalid folder ID")
	}
	if r.PublicLinkService == nil {
		return false, fmt.Errorf("public link service not configured")
	}
	if err := r.PublicLinkService.RevokeFolderLink(ctx, userID, folderUUID); err != nil {
		return false, err
	}
	return true, nil
}

// AddPublicFileToMyStorage is the resolver for the addPublicFileToMyStorage field.
func (r *mutationResolver) AddPublicFileToMyStorage(ctx context.Context, token string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user ID")
	}
	if r.PublicLinkService == nil {
		return false, fmt.Errorf("public link service not configured")
	}
	f, _, _, revoked, err := r.PublicLinkService.ResolveFileLink(ctx, token)
	if err != nil {
		return false, err
	}
	if revoked || f == nil {
		return false, fmt.Errorf("link invalid or revoked")
	}
	if err := r.PublicLinkService.AddPublicFileToStorage(ctx, userID, f.ID); err != nil {
		return false, err
	}
	return true, nil
}

// Health is the resolver for the _health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "ok", nil
}

// MyFiles is the resolver for the myFiles field.
func (r *queryResolver) MyFiles(ctx context.Context) ([]*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	ufs, err := r.FileService.GetUserFiles(ctx, userID)
	if err != nil {
		return nil, err
	}
	var out []*model.UserFile
	for _, uf := range ufs {
		// Inline pointer construction for optional fields
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		out = append(out, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				RefCount:     uf.File.RefCount,
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{
				Email:   uf.UploaderEmail,
				Name:    namePtr,
				Picture: picPtr,
			},
		})
	}
	return out, nil
}

// MyFolderFiles is the resolver for the myFolderFiles field.
func (r *queryResolver) MyFolderFiles(ctx context.Context, folderID *string) ([]*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	var fid *uuid.UUID
	if folderID != nil && *folderID != "" {
		id, err := uuid.Parse(*folderID)
		if err != nil {
			return nil, fmt.Errorf("invalid folder id")
		}
		fid = &id
	}
	ufs, err := r.FileService.FileRepo.ListUserFilesInFolder(ctx, userID, fid)
	if err != nil {
		return nil, err
	}
	out := make([]*model.UserFile, 0, len(ufs))
	for _, uf := range ufs {
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		out = append(out, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID: uf.File.ID.String(), Hash: uf.File.Hash, OriginalName: uf.File.OriginalName,
				MimeType: uf.File.MimeType, Size: int(uf.File.Size), RefCount: uf.File.RefCount,
				Visibility: uf.File.Visibility, CreatedAt: uf.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{Email: uf.UploaderEmail, Name: namePtr, Picture: picPtr},
		})
	}
	return out, nil
}

// MyDeletedFiles is the resolver for the myDeletedFiles field.
func (r *queryResolver) MyDeletedFiles(ctx context.Context) ([]*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	ufs, err := r.FileService.GetDeletedUserFiles(ctx, userID)
	if err != nil {
		return nil, err
	}
	var out []*model.UserFile
	for _, uf := range ufs {
		node := &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				RefCount:     uf.File.RefCount,
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
		}
		// Inline pointer construction for optional fields
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		node.Uploader = &model.Uploader{
			Email:   uf.UploaderEmail,
			Name:    namePtr,
			Picture: picPtr,
		}
		out = append(out, node)
	}
	return out, nil
}

// MyStorage is the resolver for the myStorage field.
func (r *queryResolver) MyStorage(ctx context.Context) (*model.StorageUsage, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	used, quota, err := r.FileService.GetUserUsage(ctx, userID)
	if err != nil {
		return nil, err
	}
	// attributed physical usage (sum of size/ref_count per file)
	attributed, err := r.FileService.GetUserAttributedUsage(ctx, userID)
	if err != nil {
		return nil, err
	}
	percent := float64(0)
	if quota > 0 {
		percent = (float64(used) / float64(quota)) * 100.0
	}
	savings := used - attributed
	if savings < 0 {
		savings = 0
	}
	savingsPercent := float64(0)
	if used > 0 {
		savingsPercent = (float64(savings) / float64(used)) * 100.0
	}
	return &model.StorageUsage{
		UsedBytes:      int(used),
		QuotaBytes:     int(quota),
		PercentUsed:    percent,
		SavingsBytes:   int(savings),
		SavingsPercent: savingsPercent,
	}, nil
}

// FindMyFileByHash is the resolver for the findMyFileByHash field.
func (r *queryResolver) FindMyFileByHash(ctx context.Context, hash string) (*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	uf, err := r.FileService.FindUserFileByHash(ctx, userID, hash)
	if err != nil {
		return nil, err
	}
	if uf == nil {
		return nil, nil
	}
	// Inline pointer construction for optional fields
	var namePtr *string
	if uf.UploaderName != "" {
		n := uf.UploaderName
		namePtr = &n
	}
	var picPtr *string
	if uf.UploaderPicture != "" {
		p := uf.UploaderPicture
		picPtr = &p
	}
	return &model.UserFile{
		ID:         uf.ID.String(),
		UserID:     uf.UserID.String(),
		FileID:     uf.FileID.String(),
		UploadedAt: uf.UploadedAt.Format(time.RFC3339),
		File: &model.File{
			ID:           uf.File.ID.String(),
			Hash:         uf.File.Hash,
			OriginalName: uf.File.OriginalName,
			MimeType:     uf.File.MimeType,
			Size:         int(uf.File.Size),
			RefCount:     uf.File.RefCount,
			Visibility:   uf.File.Visibility,
			CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
		},
		Uploader: &model.Uploader{
			Email:   uf.UploaderEmail,
			Name:    namePtr,
			Picture: picPtr,
		},
	}, nil
}

// FileURL is the resolver for the fileURL field.
func (r *queryResolver) FileURL(ctx context.Context, fileID string, inline *bool) (string, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return "", fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return "", fmt.Errorf("invalid user id in token")
	}
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return "", fmt.Errorf("invalid file id")
	}
	in := false
	if inline != nil {
		in = *inline
	}
	if r.FileService == nil {
		return "", fmt.Errorf("file service not configured")
	}

	// First try to get the file URL if user owns it
	fileURL, err := r.FileService.GetFileURL(ctx, userID, fid, in)
	if err == nil {
		fmt.Printf("DEBUG: User %s owns file %s, returning direct URL (no tracking)\n", userID, fid)
		return fileURL, nil
	}

	// If user doesn't own the file, check if it's shared with them
	fmt.Printf("DEBUG: User %s doesn't own file %s, checking for shared access\n", userID, fid)
	userEmail, err := r.ShareService.UserRepo.GetUserEmailByID(ctx, userIDStr)
	if err != nil {
		return "", fmt.Errorf("failed to get user email: %w", err)
	}

	// Check if user has access to this file via sharing
	hasAccess, _, err := r.ShareService.ShareRepo.HasFileAccess(ctx, userID, userEmail, fid)
	if err != nil {
		return "", fmt.Errorf("failed to check file access: %w", err)
	}
	if !hasAccess {
		return "", fmt.Errorf("unauthorized to access this file")
	}

	fmt.Printf("DEBUG: User %s has shared access to file %s, proceeding with download tracking\n", userID, fid)

	// User has access via sharing; generate presigned URL directly (replicates former GetSharedFileURL logic)
	file, err := r.FileService.FileRepo.GetByID(ctx, fid)
	if err != nil {
		return "", err
	}
	if file == nil {
		return "", fmt.Errorf("file not found")
	}

	// Track the download for shared files
	// Get the owner ID of the file first
	ownerUserFile, err := r.FileService.FileRepo.GetOwnerByFileID(ctx, fid)
	if err == nil && ownerUserFile != nil && r.FileDownloadService != nil {
		// Record the download tracking (fire and forget, don't fail if tracking fails)
		go func() {
			// Validate that the downloader and owner are different to avoid self-downloads
			if userID != ownerUserFile.UserID {
				fmt.Printf("TRACKING: Recording download - File: %s, Owner: %s, Downloader: %s\n", fid, ownerUserFile.UserID, userID)
				err := r.FileDownloadService.DownloadRepo.RecordDownload(context.Background(), fid, ownerUserFile.UserID, &userID, "shared", "", "GraphQL", "GraphQL-Client")
				if err != nil {
					// Log error but don't fail the request - tracking is not critical
					fmt.Printf("WARNING: Failed to record download tracking: %v\n", err)
				} else {
					fmt.Printf("SUCCESS: Download recorded successfully\n")
				}
			} else {
				fmt.Printf("SKIPPING: Owner downloading their own file - File: %s, User: %s\n", fid, userID)
			}
		}()
	} else {
		if err != nil {
			fmt.Printf("ERROR: Failed to get file owner: %v\n", err)
		}
		if ownerUserFile == nil {
			fmt.Printf("ERROR: Owner user file is nil for file: %s\n", fid)
		}
		if r.FileDownloadService == nil {
			fmt.Printf("ERROR: FileDownloadService is nil\n")
		}
	}

	// Prepare response-content-disposition
	dispType := "attachment"
	if in {
		dispType = "inline"
	}
	reqParams := url.Values{}
	reqParams.Set("response-content-disposition", fmt.Sprintf("%s; filename=\"%s\"", dispType, file.OriginalName))

	expiry := 10 * time.Minute
	u, err := r.FileService.Minio.PresignedGetObject(ctx, r.FileService.Bucket, file.StoragePath, expiry, reqParams)
	if err != nil {
		return "", err
	}
	if r.FileService.PublicEndpoint != "" {
		if base, perr := url.Parse(r.FileService.PublicEndpoint); perr == nil {
			u.Scheme = base.Scheme
			u.Host = base.Host
		}
	}
	return u.String(), nil
}

// SearchMyFiles is the resolver for the searchMyFiles field.
func (r *queryResolver) SearchMyFiles(ctx context.Context, filter model.FileSearchFilter, pagination *model.PageInput) (*model.UserFileConnection, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	// Map GraphQL filter to repo filter
	rf := repository.SearchFilter{}
	if filter.Filename != nil && *filter.Filename != "" {
		rf.Filename = filter.Filename
	}
	if len(filter.MimeTypes) > 0 {
		rf.MimeTypes = filter.MimeTypes
	}
	if filter.SizeMin != nil {
		v := int64(*filter.SizeMin)
		rf.SizeMin = &v
	}
	if filter.SizeMax != nil {
		v := int64(*filter.SizeMax)
		rf.SizeMax = &v
	}
	if filter.CreatedAfter != nil && *filter.CreatedAfter != "" {
		if t, err := time.Parse(time.RFC3339, *filter.CreatedAfter); err == nil {
			rf.CreatedAfter = &t
		}
	}
	if filter.CreatedBefore != nil && *filter.CreatedBefore != "" {
		if t, err := time.Parse(time.RFC3339, *filter.CreatedBefore); err == nil {
			rf.CreatedBefore = &t
		}
	}
	if len(filter.Tags) > 0 {
		rf.Tags = filter.Tags
	}
	if filter.UploaderName != nil && *filter.UploaderName != "" {
		rf.UploaderName = filter.UploaderName
	}

	pg := repository.Page{Limit: 50}
	if pagination != nil {
		if pagination.Limit != nil {
			pg.Limit = *pagination.Limit
		}
		pg.Cursor = pagination.Cursor
	}

	items, next, total, err := r.FileService.SearchUserFiles(ctx, userID, rf, pg)
	if err != nil {
		return nil, err
	}

	edges := []*model.UserFileEdge{}
	for _, uf := range items {
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		edges = append(edges, &model.UserFileEdge{
			Cursor: fmt.Sprintf("%d:%s", uf.UploadedAt.UnixNano(), uf.ID.String()),
			Node: &model.UserFile{
				ID:         uf.ID.String(),
				UserID:     uf.UserID.String(),
				FileID:     uf.FileID.String(),
				UploadedAt: uf.UploadedAt.Format(time.RFC3339),
				File: &model.File{
					ID:           uf.File.ID.String(),
					Hash:         uf.File.Hash,
					OriginalName: uf.File.OriginalName,
					MimeType:     uf.File.MimeType,
					Size:         int(uf.File.Size),
					RefCount:     uf.File.RefCount,
					Visibility:   uf.File.Visibility,
					CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
				},
				Uploader: &model.Uploader{
					Email:   uf.UploaderEmail,
					Name:    namePtr,
					Picture: picPtr,
				},
			},
		})
	}

	return &model.UserFileConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			EndCursor:   next,
			HasNextPage: next != nil,
		},
		TotalCount: total,
	}, nil
}

// MyFolders is the resolver for the myFolders field.
func (r *queryResolver) MyFolders(ctx context.Context, parentID *string) ([]*model.Folder, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FolderService == nil {
		return nil, fmt.Errorf("folder service not configured")
	}
	var pid *uuid.UUID
	if parentID != nil && *parentID != "" {
		id, err := uuid.Parse(*parentID)
		if err != nil {
			return nil, fmt.Errorf("invalid parent id")
		}
		pid = &id
	}
	folders, err := r.FolderService.Repo.ListFolders(ctx, userID, pid)
	if err != nil {
		return nil, err
	}
	var out []*model.Folder
	for _, f := range folders {
		var pStr *string
		if f.ParentID != nil {
			s := f.ParentID.String()
			pStr = &s
		}
		out = append(out, &model.Folder{ID: f.ID.String(), Name: f.Name, ParentID: pStr, CreatedAt: f.CreatedAt.Format(time.RFC3339)})
	}
	return out, nil
}

// SharedFilesWithMe is the resolver for the sharedFilesWithMe field.
func (r *queryResolver) SharedFilesWithMe(ctx context.Context) ([]*model.SharedFileWithMe, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	shares, err := r.ShareService.GetSharedFilesWithMe(ctx, userID)
	if err != nil {
		return nil, err
	}

	var result []*model.SharedFileWithMe
	for _, share := range shares {
		result = append(result, &model.SharedFileWithMe{
			ID:              share.ID.String(),
			FileID:          share.FileID.String(),
			OwnerID:         share.OwnerID.String(),
			SharedWithEmail: share.SharedWithEmail,
			Permission:      share.Permission,
			SharedAt:        share.SharedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           share.File.ID.String(),
				Hash:         share.File.Hash,
				OriginalName: share.File.OriginalName,
				MimeType:     share.File.MimeType,
				Size:         int(share.File.Size),
				RefCount:     int(share.File.RefCount),
				Visibility:   share.File.Visibility,
				CreatedAt:    share.File.CreatedAt.Format(time.RFC3339),
			},
			Owner: &model.User{
				ID:        share.Owner.ID.String(),
				Email:     share.Owner.Email,
				CreatedAt: share.Owner.CreatedAt.Format(time.RFC3339),
				UpdatedAt: share.Owner.CreatedAt.Format(time.RFC3339),
			},
		})
	}

	return result, nil
}

// SharedFoldersWithMe is the resolver for the sharedFoldersWithMe field.
func (r *queryResolver) SharedFoldersWithMe(ctx context.Context) ([]*model.SharedFolderWithMe, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	shares, err := r.ShareService.GetSharedFoldersWithMe(ctx, userID)
	if err != nil {
		return nil, err
	}

	var result []*model.SharedFolderWithMe
	for _, share := range shares {
		// Handle nullable ParentID
		var parentIDStr *string
		if share.Folder.ParentID != nil {
			str := share.Folder.ParentID.String()
			parentIDStr = &str
		}

		result = append(result, &model.SharedFolderWithMe{
			ID:              share.ID.String(),
			FolderID:        share.FolderID.String(),
			OwnerID:         share.OwnerID.String(),
			SharedWithEmail: share.SharedWithEmail,
			Permission:      share.Permission,
			SharedAt:        share.SharedAt.Format(time.RFC3339),
			Folder: &model.Folder{
				ID:        share.Folder.ID.String(),
				Name:      share.Folder.Name,
				ParentID:  parentIDStr,
				CreatedAt: share.Folder.CreatedAt.Format(time.RFC3339),
			},
			Owner: &model.User{
				ID:        share.Owner.ID.String(),
				Email:     share.Owner.Email,
				CreatedAt: share.Owner.CreatedAt.Format(time.RFC3339),
				UpdatedAt: share.Owner.CreatedAt.Format(time.RFC3339),
			},
		})
	}

	return result, nil
}

// SharedFolderFiles is the resolver for the sharedFolderFiles field.
func (r *queryResolver) SharedFolderFiles(ctx context.Context, folderID string) ([]*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	folderUUID, err := uuid.Parse(folderID)
	if err != nil {
		return nil, fmt.Errorf("invalid folder ID")
	}

	// Get files in the shared folder (access check is done in the service)
	files, err := r.ShareService.GetSharedFolderFiles(ctx, userID, folderUUID)
	if err != nil {
		return nil, err
	}

	var result []*model.UserFile
	for _, file := range files {
		result = append(result, &model.UserFile{
			ID:         file.ID.String(),
			UserID:     file.UserID.String(),
			FileID:     file.FileID.String(),
			UploadedAt: file.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           file.File.ID.String(),
				Hash:         file.File.Hash,
				OriginalName: file.File.OriginalName,
				MimeType:     file.File.MimeType,
				Size:         int(file.File.Size),
				RefCount:     file.File.RefCount,
				Visibility:   file.File.Visibility,
				CreatedAt:    file.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{
				Email:   file.UploaderEmail,
				Name:    &file.UploaderName,
				Picture: &file.UploaderPicture,
			},
		})
	}

	return result, nil
}

// FileShares is the resolver for the fileShares field.
func (r *queryResolver) FileShares(ctx context.Context, fileID string) ([]*model.FileShare, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	fileUUID, err := uuid.Parse(fileID)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID")
	}

	shares, err := r.ShareService.GetFileShares(ctx, userID, fileUUID)
	if err != nil {
		return nil, err
	}

	var result []*model.FileShare
	for _, share := range shares {

		result = append(result, &model.FileShare{
			ID:              share.ID.String(),
			FileID:          share.FileID.String(),
			OwnerID:         share.OwnerID.String(),
			SharedWithEmail: share.SharedWithEmail,
			Permission:      share.Permission,
			SharedAt:        share.SharedAt.Format(time.RFC3339),
		})
	}

	return result, nil
}

// FolderShares is the resolver for the folderShares field.
func (r *queryResolver) FolderShares(ctx context.Context, folderID string) ([]*model.FolderShare, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	folderUUID, err := uuid.Parse(folderID)
	if err != nil {
		return nil, fmt.Errorf("invalid folder ID")
	}

	shares, err := r.ShareService.GetFolderShares(ctx, userID, folderUUID)
	if err != nil {
		return nil, err
	}

	var result []*model.FolderShare
	for _, share := range shares {
		result = append(result, &model.FolderShare{
			ID:              share.ID.String(),
			FolderID:        share.FolderID.String(),
			OwnerID:         share.OwnerID.String(),
			SharedWithEmail: share.SharedWithEmail,
			Permission:      share.Permission,
			SharedAt:        share.SharedAt.Format(time.RFC3339),
		})
	}

	return result, nil
}

// ResolvePublicFileLink is the resolver for the resolvePublicFileLink field.
func (r *queryResolver) ResolvePublicFileLink(ctx context.Context, token string) (*model.PublicFileLinkResolved, error) {
	if r.PublicLinkService == nil {
		return nil, fmt.Errorf("public link service not configured")
	}
	f, owner, expiresAt, revoked, err := r.PublicLinkService.ResolveFileLink(ctx, token)
	if err != nil {
		return nil, err
	}
	if revoked || f == nil || owner == nil {
		return &model.PublicFileLinkResolved{Token: token, Revoked: true}, nil
	}

	// Track the download for public links (assuming resolution indicates download intent)
	if r.FileDownloadService != nil {
		// Try to get user ID from context (might be nil for anonymous access)
		var downloadedBy *uuid.UUID
		if userIDStr, ok := middleware.GetUserIDFromContext(ctx); ok {
			if userID, err := uuid.Parse(userIDStr); err == nil {
				downloadedBy = &userID
			}
		}

		// Record the download tracking (fire and forget, don't fail if tracking fails)
		go func() {
			err := r.FileDownloadService.DownloadRepo.RecordDownload(context.Background(), f.ID, owner.ID, downloadedBy, "public", token, "", "")
			if err != nil {
				fmt.Printf("WARNING: Failed to record public download tracking: %v\n", err)
			}
		}()
	}

	var expStr *string
	if expiresAt != nil {
		s := expiresAt.Format(time.RFC3339)
		expStr = &s
	}
	return &model.PublicFileLinkResolved{
		Token: token,
		File: &model.File{
			ID:           f.ID.String(),
			Hash:         f.Hash,
			OriginalName: f.OriginalName,
			MimeType:     f.MimeType,
			Size:         int(f.Size),
			RefCount:     f.RefCount,
			Visibility:   f.Visibility,
			CreatedAt:    f.CreatedAt.Format(time.RFC3339),
		},
		Owner:     &model.User{ID: owner.ID.String(), Email: owner.Email, CreatedAt: owner.CreatedAt.Format(time.RFC3339), UpdatedAt: owner.CreatedAt.Format(time.RFC3339)},
		ExpiresAt: expStr,
		Revoked:   false,
	}, nil
}

// ResolvePublicFolderLink is the resolver for the resolvePublicFolderLink field.
func (r *queryResolver) ResolvePublicFolderLink(ctx context.Context, token string) (*model.PublicFolderLinkResolved, error) {
	if r.PublicLinkService == nil {
		return nil, fmt.Errorf("public link service not configured")
	}
	fo, owner, expiresAt, revoked, err := r.PublicLinkService.ResolveFolderLink(ctx, token)
	if err != nil {
		return nil, err
	}
	if revoked || fo == nil || owner == nil {
		return &model.PublicFolderLinkResolved{Token: token, Revoked: true}, nil
	}
	var expStr *string
	if expiresAt != nil {
		s := expiresAt.Format(time.RFC3339)
		expStr = &s
	}
	var parentID *string
	if fo.ParentID != nil {
		p := fo.ParentID.String()
		parentID = &p
	}
	return &model.PublicFolderLinkResolved{
		Token: token,
		Folder: &model.Folder{
			ID:        fo.ID.String(),
			Name:      fo.Name,
			ParentID:  parentID,
			CreatedAt: fo.CreatedAt.Format(time.RFC3339),
		},
		Owner:     &model.User{ID: owner.ID.String(), Email: owner.Email, CreatedAt: owner.CreatedAt.Format(time.RFC3339), UpdatedAt: owner.CreatedAt.Format(time.RFC3339)},
		ExpiresAt: expStr,
		Revoked:   false,
	}, nil
}

// PublicFolderFiles is the resolver for the publicFolderFiles field.
func (r *queryResolver) PublicFolderFiles(ctx context.Context, token string) ([]*model.UserFile, error) {
	if r.PublicLinkService == nil {
		return nil, fmt.Errorf("public link service not configured")
	}
	if r.ShareService == nil {
		return nil, fmt.Errorf("share service not configured")
	}

	// First resolve the public folder link to get the folder
	folder, _, _, revoked, err := r.PublicLinkService.ResolveFolderLink(ctx, token)
	if err != nil {
		return nil, err
	}
	if revoked || folder == nil {
		return nil, fmt.Errorf("folder link not found or has been revoked")
	}

	// Get the files in this folder
	userFiles, err := r.ShareService.GetPublicFolderFiles(ctx, folder.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to get folder files: %w", err)
	}

	// Convert to GraphQL model format (same as SharedFolderFiles)
	var result []*model.UserFile
	for _, file := range userFiles {
		result = append(result, &model.UserFile{
			ID:         file.ID.String(),
			UserID:     file.UserID.String(),
			FileID:     file.FileID.String(),
			UploadedAt: file.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           file.File.ID.String(),
				Hash:         file.File.Hash,
				OriginalName: file.File.OriginalName,
				MimeType:     file.File.MimeType,
				Size:         int(file.File.Size),
				RefCount:     file.File.RefCount,
				Visibility:   file.File.Visibility,
				CreatedAt:    file.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{
				Email:   file.UploaderEmail,
				Name:    &file.UploaderName,
				Picture: &file.UploaderPicture,
			},
		})
	}

	return result, nil
}

// AdminAllUsers is the resolver for the adminAllUsers field.
// AdminAllUsers is the resolver for the adminAllUsers field.
func (r *queryResolver) AdminAllUsers(ctx context.Context) ([]*model.AdminUserInfo, error) {
	// Check if user is admin
	isAdmin := middleware.GetIsAdminFromContext(ctx)
	if !isAdmin {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// Get all users from admin service
	users, err := r.AdminService.GetAllUsers(ctx)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	var result []*model.AdminUserInfo
	for _, user := range users {
		result = append(result, &model.AdminUserInfo{
			ID:           user.ID.String(),
			Email:        user.Email,
			Name:         &user.Name,
			Picture:      &user.Picture,
			CreatedAt:    user.CreatedAt.Format(time.RFC3339),
			UpdatedAt:    user.UpdatedAt.Format(time.RFC3339),
			TotalFiles:   user.TotalFiles,
			TotalFolders: user.TotalFolders,
			StorageUsed:  int(user.StorageUsed),
		})
	}

	return result, nil
}

// AdminUserFiles is the resolver for the adminUserFiles field.
func (r *queryResolver) AdminUserFiles(ctx context.Context, userID string) ([]*model.UserFile, error) {
	// Check if user is admin
	isAdmin := middleware.GetIsAdminFromContext(ctx)
	if !isAdmin {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// Parse userID
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Get user files from admin service
	userFiles, err := r.AdminService.GetUserFiles(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model (similar pattern to MyFiles resolver)
	var result []*model.UserFile
	for _, uf := range userFiles {
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picturePtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picturePtr = &p
		}

		result = append(result, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				RefCount:     uf.File.RefCount,
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{
				Email:   uf.UploaderEmail,
				Name:    namePtr,
				Picture: picturePtr,
			},
		})
	}

	return result, nil
}

// AdminUserFolders is the resolver for the adminUserFolders field.
func (r *queryResolver) AdminUserFolders(ctx context.Context, userID string) ([]*model.Folder, error) {
	// Check if user is admin
	isAdmin := middleware.GetIsAdminFromContext(ctx)
	if !isAdmin {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// Parse userID
	uid, err := uuid.Parse(userID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Get user folders from admin service
	folders, err := r.AdminService.GetUserFolders(ctx, uid)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	var result []*model.Folder
	for _, folder := range folders {
		var parentIDPtr *string
		if folder.ParentID != nil {
			p := folder.ParentID.String()
			parentIDPtr = &p
		}

		result = append(result, &model.Folder{
			ID:        folder.ID.String(),
			Name:      folder.Name,
			ParentID:  parentIDPtr,
			CreatedAt: folder.CreatedAt.Format(time.RFC3339),
		})
	}

	return result, nil
}

// AdminFileDownloadStats is the resolver for the adminFileDownloadStats field.
func (r *queryResolver) AdminFileDownloadStats(ctx context.Context) ([]*model.FileDownloadStats, error) {
	// Check if user is admin
	isAdmin := middleware.GetIsAdminFromContext(ctx)
	if !isAdmin {
		return nil, fmt.Errorf("unauthorized: admin access required")
	}

	// Get download stats from service
	stats, err := r.FileDownloadService.GetAllFileDownloadStats(ctx)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	var result []*model.FileDownloadStats
	for _, stat := range stats {
		var lastDownloadAt *string
		if stat.LastDownloadAt != nil {
			formatted := stat.LastDownloadAt.Format(time.RFC3339)
			lastDownloadAt = &formatted
		}

		result = append(result, &model.FileDownloadStats{
			FileID:          stat.FileID.String(),
			OwnerID:         stat.OwnerID.String(),
			TotalDownloads:  int(stat.TotalDownloads),
			SharedDownloads: int(stat.SharedDownloads),
			PublicDownloads: int(stat.PublicDownloads),
			LastDownloadAt:  lastDownloadAt,
			File: &model.File{
				ID:           stat.File.ID.String(),
				Hash:         stat.File.Hash,
				OriginalName: stat.File.OriginalName,
				MimeType:     stat.File.MimeType,
				Size:         int(stat.File.Size),
				RefCount:     stat.File.RefCount,
				Visibility:   stat.File.Visibility,
				CreatedAt:    stat.File.CreatedAt.Format(time.RFC3339),
			},
			Owner: &model.User{
				ID:        stat.Owner.ID.String(),
				Email:     stat.Owner.Email,
				CreatedAt: stat.Owner.CreatedAt.Format(time.RFC3339),
				IsAdmin:   r.AuthService.IsAdmin(stat.Owner.Email),
			},
		})
	}

	return result, nil
}

// MyFileDownloads is the resolver for the myFileDownloads field.
func (r *queryResolver) MyFileDownloads(ctx context.Context, fileID string) ([]*model.FileDownload, error) {
	// Get user ID from context
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Parse user ID
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Parse file ID
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return nil, fmt.Errorf("invalid file ID")
	}

	// Get downloads from service
	downloads, err := r.FileDownloadService.GetFileDownloads(ctx, userID, fid)
	if err != nil {
		return nil, err
	}

	// Convert to GraphQL model
	var result []*model.FileDownload
	for _, download := range downloads {
		var downloadedBy *string
		if download.DownloadedBy != nil {
			d := download.DownloadedBy.String()
			downloadedBy = &d
		}

		var shareToken *string
		if download.ShareToken != nil {
			shareToken = download.ShareToken
		}

		var downloadedUser *model.User
		if download.DownloadedUser != nil {
			downloadedUser = &model.User{
				ID:        download.DownloadedUser.ID.String(),
				Email:     download.DownloadedUser.Email,
				CreatedAt: download.DownloadedUser.CreatedAt.Format(time.RFC3339),
				IsAdmin:   r.AuthService.IsAdmin(download.DownloadedUser.Email),
			}
		}

		result = append(result, &model.FileDownload{
			ID:           download.ID.String(),
			FileID:       download.FileID.String(),
			DownloadedBy: downloadedBy,
			OwnerID:      download.OwnerID.String(),
			DownloadType: download.DownloadType,
			ShareToken:   shareToken,
			IPAddress:    download.IPAddress,
			UserAgent:    download.UserAgent,
			DownloadedAt: download.DownloadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           download.File.ID.String(),
				Hash:         download.File.Hash,
				OriginalName: download.File.OriginalName,
				MimeType:     download.File.MimeType,
				Size:         int(download.File.Size),
				RefCount:     download.File.RefCount,
				Visibility:   download.File.Visibility,
				CreatedAt:    download.File.CreatedAt.Format(time.RFC3339),
			},
			DownloadedUser: downloadedUser,
			Owner: &model.User{
				ID:        download.Owner.ID.String(),
				Email:     download.Owner.Email,
				CreatedAt: download.Owner.CreatedAt.Format(time.RFC3339),
				IsAdmin:   r.AuthService.IsAdmin(download.Owner.Email),
			},
		})
	}

	return result, nil
}

// MySharedFileDownloads is the resolver for the mySharedFileDownloads field.
func (r *queryResolver) MySharedFileDownloads(ctx context.Context) ([]*model.FileDownload, error) {
	// Get user ID from context
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}

	// Parse user ID
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	fmt.Printf("DEBUG: MySharedFileDownloads called by user: %s\n", userID)

	// Get downloads from service
	fmt.Printf("DEBUG: Getting shared file downloads for user: %s\n", userID)
	downloads, err := r.FileDownloadService.GetMySharedFileDownloads(ctx, userID)
	if err != nil {
		fmt.Printf("ERROR: Failed to get shared file downloads: %v\n", err)
		return nil, err
	}

	fmt.Printf("DEBUG: Found %d downloads in database for user %s\n", len(downloads), userID)

	// Convert to GraphQL model
	var result []*model.FileDownload
	for _, download := range downloads {
		var downloadedBy *string
		if download.DownloadedBy != nil {
			d := download.DownloadedBy.String()
			downloadedBy = &d
		}

		var shareToken *string
		if download.ShareToken != nil {
			shareToken = download.ShareToken
		}

		var downloadedUser *model.User
		if download.DownloadedUser != nil {
			downloadedUser = &model.User{
				ID:        download.DownloadedUser.ID.String(),
				Email:     download.DownloadedUser.Email,
				CreatedAt: download.DownloadedUser.CreatedAt.Format(time.RFC3339),
				IsAdmin:   r.AuthService.IsAdmin(download.DownloadedUser.Email),
			}
		}

		result = append(result, &model.FileDownload{
			ID:           download.ID.String(),
			FileID:       download.FileID.String(),
			DownloadedBy: downloadedBy,
			OwnerID:      download.OwnerID.String(),
			DownloadType: download.DownloadType,
			ShareToken:   shareToken,
			IPAddress:    download.IPAddress,
			UserAgent:    download.UserAgent,
			DownloadedAt: download.DownloadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           download.File.ID.String(),
				Hash:         download.File.Hash,
				OriginalName: download.File.OriginalName,
				MimeType:     download.File.MimeType,
				Size:         int(download.File.Size),
				RefCount:     download.File.RefCount,
				Visibility:   download.File.Visibility,
				CreatedAt:    download.File.CreatedAt.Format(time.RFC3339),
			},
			DownloadedUser: downloadedUser,
			Owner: &model.User{
				ID:        download.Owner.ID.String(),
				Email:     download.Owner.Email,
				CreatedAt: download.Owner.CreatedAt.Format(time.RFC3339),
				IsAdmin:   r.AuthService.IsAdmin(download.Owner.Email),
			},
		})
	}

	return result, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
