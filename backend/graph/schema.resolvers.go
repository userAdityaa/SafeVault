package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.80

import (
	"context"
	"fmt"
	"time"

	"github.com/99designs/gqlgen/graphql"
	"github.com/google/uuid"
	"github.com/useradityaa/graph/model"
	"github.com/useradityaa/internal/middleware"
	"github.com/useradityaa/internal/repository"
)

// Signup is the resolver for the signup field.
func (r *mutationResolver) Signup(ctx context.Context, input model.SignupInput) (*model.AuthPayload, error) {
	user, token, err := r.AuthService.Signup(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:    user.ID.String(),
			Email: user.Email,
		},
	}, nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, input model.LoginInput) (*model.AuthPayload, error) {
	user, token, err := r.AuthService.Login(ctx, input.Email, input.Password)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:    user.ID.String(),
			Email: user.Email,
		},
	}, nil
}

// GoogleLogin is the resolver for the googleLogin field.
func (r *mutationResolver) GoogleLogin(ctx context.Context, input model.GoogleLoginInput) (*model.AuthPayload, error) {
	user, token, err := r.GoogleService.LoginWithGoogle(ctx, input.IDToken)
	if err != nil {
		return nil, err
	}

	return &model.AuthPayload{
		Token: token,
		User: &model.User{
			ID:      user.ID.String(),
			Email:   user.Email,
			Name:    &user.Name,
			Picture: &user.Picture,
		},
	}, nil
}

// UploadFiles is the resolver for the uploadFiles field.
func (r *mutationResolver) UploadFiles(ctx context.Context, input model.UploadFileInput) ([]*model.UserFile, error) {
	// Require authentication
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}

	// Convert GraphQL uploads to the type FileService expects
	var uploads []*graphql.Upload
	for _, up := range input.Files {
		if up == nil || up.File == nil {
			return nil, fmt.Errorf("invalid file input")
		}
		uploads = append(uploads, up)
	}

	if r.FileService == nil {
		return nil, fmt.Errorf("file storage not configured")
	}

	// Pass allowDuplicate down via context for now (small change without altering service signature)
	if input.AllowDuplicate != nil && *input.AllowDuplicate {
		ctx = context.WithValue(ctx, struct{ key string }{"allowDuplicate"}, true)
	}
	userFiles, err := r.FileService.UploadFiles(ctx, userID, uploads)
	if err != nil {
		return nil, err
	}

	// Map to GraphQL models
	var gqlFiles []*model.UserFile
	for _, uf := range userFiles {
		// Inline pointer construction for optional fields
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		gqlFiles = append(gqlFiles, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				RefCount:     uf.File.RefCount,
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{
				Email:   uf.UploaderEmail,
				Name:    namePtr,
				Picture: picPtr,
			},
		})
	}

	return gqlFiles, nil
}

// DeleteFile is the resolver for the deleteFile field.
func (r *mutationResolver) DeleteFile(ctx context.Context, fileID string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file id")
	}
	if r.FileService == nil {
		return false, fmt.Errorf("file service not configured")
	}
	if err := r.FileService.SoftDeleteUserFile(ctx, userID, fid); err != nil {
		return false, err
	}
	return true, nil
}

// PurgeFile is the resolver for the purgeFile field.
func (r *mutationResolver) PurgeFile(ctx context.Context, fileID string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return false, fmt.Errorf("invalid file id")
	}
	if r.FileService == nil {
		return false, fmt.Errorf("file service not configured")
	}
	if err := r.FileService.PurgeUserFile(ctx, userID, fid); err != nil {
		return false, err
	}
	return true, nil
}

// CreateFolder is the resolver for the createFolder field.
func (r *mutationResolver) CreateFolder(ctx context.Context, name string, parentID *string) (*model.Folder, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FolderService == nil {
		return nil, fmt.Errorf("folder service not configured")
	}
	var pid *uuid.UUID
	if parentID != nil && *parentID != "" {
		id, err := uuid.Parse(*parentID)
		if err != nil {
			return nil, fmt.Errorf("invalid parent id")
		}
		pid = &id
	}
	id, err := r.FolderService.CreateFolder(ctx, userID, name, pid)
	if err != nil {
		return nil, err
	}
	// Load created folder
	// We don't have a direct getter in service; return minimal payload
	now := time.Now().Format(time.RFC3339)
	var pidStr *string
	if pid != nil {
		s := pid.String()
		pidStr = &s
	}
	return &model.Folder{ID: id.String(), Name: name, ParentID: pidStr, CreatedAt: now}, nil
}

// RenameFolder is the resolver for the renameFolder field.
func (r *mutationResolver) RenameFolder(ctx context.Context, folderID string, newName string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	if r.FolderService == nil {
		return false, fmt.Errorf("folder service not configured")
	}
	fid, err := uuid.Parse(folderID)
	if err != nil {
		return false, fmt.Errorf("invalid folder id")
	}
	if err := r.FolderService.RenameFolder(ctx, userID, fid, newName); err != nil {
		return false, err
	}
	return true, nil
}

// DeleteFolder is the resolver for the deleteFolder field.
func (r *mutationResolver) DeleteFolder(ctx context.Context, folderID string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	if r.FolderService == nil {
		return false, fmt.Errorf("folder service not configured")
	}
	fid, err := uuid.Parse(folderID)
	if err != nil {
		return false, fmt.Errorf("invalid folder id")
	}
	if err := r.FolderService.DeleteFolder(ctx, userID, fid); err != nil {
		return false, err
	}
	return true, nil
}

// MoveUserFile is the resolver for the moveUserFile field.
func (r *mutationResolver) MoveUserFile(ctx context.Context, mappingID string, folderID *string) (bool, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return false, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return false, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return false, fmt.Errorf("file service not configured")
	}
	mid, err := uuid.Parse(mappingID)
	if err != nil {
		return false, fmt.Errorf("invalid mapping id")
	}
	var fid *uuid.UUID
	if folderID != nil && *folderID != "" {
		id, err := uuid.Parse(*folderID)
		if err != nil {
			return false, fmt.Errorf("invalid folder id")
		}
		fid = &id
	}
	if err := r.FileService.FileRepo.MoveUserFileToFolder(ctx, userID, mid, fid); err != nil {
		return false, err
	}
	return true, nil
}

// Health is the resolver for the _health field.
func (r *queryResolver) Health(ctx context.Context) (string, error) {
	return "ok", nil
}

// MyFiles is the resolver for the myFiles field.
func (r *queryResolver) MyFiles(ctx context.Context) ([]*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	ufs, err := r.FileService.GetUserFiles(ctx, userID)
	if err != nil {
		return nil, err
	}
	var out []*model.UserFile
	for _, uf := range ufs {
		// Inline pointer construction for optional fields
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		out = append(out, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				RefCount:     uf.File.RefCount,
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{
				Email:   uf.UploaderEmail,
				Name:    namePtr,
				Picture: picPtr,
			},
		})
	}
	return out, nil
}

// MyFolderFiles is the resolver for the myFolderFiles field.
func (r *queryResolver) MyFolderFiles(ctx context.Context, folderID *string) ([]*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	var fid *uuid.UUID
	if folderID != nil && *folderID != "" {
		id, err := uuid.Parse(*folderID)
		if err != nil {
			return nil, fmt.Errorf("invalid folder id")
		}
		fid = &id
	}
	ufs, err := r.FileService.FileRepo.ListUserFilesInFolder(ctx, userID, fid)
	if err != nil {
		return nil, err
	}
	out := make([]*model.UserFile, 0, len(ufs))
	for _, uf := range ufs {
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		out = append(out, &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID: uf.File.ID.String(), Hash: uf.File.Hash, OriginalName: uf.File.OriginalName,
				MimeType: uf.File.MimeType, Size: int(uf.File.Size), RefCount: uf.File.RefCount,
				Visibility: uf.File.Visibility, CreatedAt: uf.File.CreatedAt.Format(time.RFC3339),
			},
			Uploader: &model.Uploader{Email: uf.UploaderEmail, Name: namePtr, Picture: picPtr},
		})
	}
	return out, nil
}

// MyDeletedFiles is the resolver for the myDeletedFiles field.
func (r *queryResolver) MyDeletedFiles(ctx context.Context) ([]*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	ufs, err := r.FileService.GetDeletedUserFiles(ctx, userID)
	if err != nil {
		return nil, err
	}
	var out []*model.UserFile
	for _, uf := range ufs {
		node := &model.UserFile{
			ID:         uf.ID.String(),
			UserID:     uf.UserID.String(),
			FileID:     uf.FileID.String(),
			UploadedAt: uf.UploadedAt.Format(time.RFC3339),
			File: &model.File{
				ID:           uf.File.ID.String(),
				Hash:         uf.File.Hash,
				OriginalName: uf.File.OriginalName,
				MimeType:     uf.File.MimeType,
				Size:         int(uf.File.Size),
				RefCount:     uf.File.RefCount,
				Visibility:   uf.File.Visibility,
				CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
			},
		}
		// Inline pointer construction for optional fields
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		node.Uploader = &model.Uploader{
			Email:   uf.UploaderEmail,
			Name:    namePtr,
			Picture: picPtr,
		}
		out = append(out, node)
	}
	return out, nil
}

// MyStorage is the resolver for the myStorage field.
func (r *queryResolver) MyStorage(ctx context.Context) (*model.StorageUsage, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	used, quota, err := r.FileService.GetUserUsage(ctx, userID)
	if err != nil {
		return nil, err
	}
	// attributed physical usage (sum of size/ref_count per file)
	attributed, err := r.FileService.GetUserAttributedUsage(ctx, userID)
	if err != nil {
		return nil, err
	}
	percent := float64(0)
	if quota > 0 {
		percent = (float64(used) / float64(quota)) * 100.0
	}
	savings := used - attributed
	if savings < 0 {
		savings = 0
	}
	savingsPercent := float64(0)
	if used > 0 {
		savingsPercent = (float64(savings) / float64(used)) * 100.0
	}
	return &model.StorageUsage{
		UsedBytes:      int(used),
		QuotaBytes:     int(quota),
		PercentUsed:    percent,
		SavingsBytes:   int(savings),
		SavingsPercent: savingsPercent,
	}, nil
}

// FindMyFileByHash is the resolver for the findMyFileByHash field.
func (r *queryResolver) FindMyFileByHash(ctx context.Context, hash string) (*model.UserFile, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	uf, err := r.FileService.FindUserFileByHash(ctx, userID, hash)
	if err != nil {
		return nil, err
	}
	if uf == nil {
		return nil, nil
	}
	// Inline pointer construction for optional fields
	var namePtr *string
	if uf.UploaderName != "" {
		n := uf.UploaderName
		namePtr = &n
	}
	var picPtr *string
	if uf.UploaderPicture != "" {
		p := uf.UploaderPicture
		picPtr = &p
	}
	return &model.UserFile{
		ID:         uf.ID.String(),
		UserID:     uf.UserID.String(),
		FileID:     uf.FileID.String(),
		UploadedAt: uf.UploadedAt.Format(time.RFC3339),
		File: &model.File{
			ID:           uf.File.ID.String(),
			Hash:         uf.File.Hash,
			OriginalName: uf.File.OriginalName,
			MimeType:     uf.File.MimeType,
			Size:         int(uf.File.Size),
			RefCount:     uf.File.RefCount,
			Visibility:   uf.File.Visibility,
			CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
		},
		Uploader: &model.Uploader{
			Email:   uf.UploaderEmail,
			Name:    namePtr,
			Picture: picPtr,
		},
	}, nil
}

// FileURL is the resolver for the fileURL field.
func (r *queryResolver) FileURL(ctx context.Context, fileID string, inline *bool) (string, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return "", fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return "", fmt.Errorf("invalid user id in token")
	}
	fid, err := uuid.Parse(fileID)
	if err != nil {
		return "", fmt.Errorf("invalid file id")
	}
	in := false
	if inline != nil {
		in = *inline
	}
	if r.FileService == nil {
		return "", fmt.Errorf("file service not configured")
	}
	return r.FileService.GetFileURL(ctx, userID, fid, in)
}

// SearchMyFiles is the resolver for the searchMyFiles field.
func (r *queryResolver) SearchMyFiles(ctx context.Context, filter model.FileSearchFilter, pagination *model.PageInput) (*model.UserFileConnection, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FileService == nil {
		return nil, fmt.Errorf("file service not configured")
	}
	// Map GraphQL filter to repo filter
	rf := repository.SearchFilter{}
	if filter.Filename != nil && *filter.Filename != "" {
		rf.Filename = filter.Filename
	}
	if len(filter.MimeTypes) > 0 {
		rf.MimeTypes = filter.MimeTypes
	}
	if filter.SizeMin != nil {
		v := int64(*filter.SizeMin)
		rf.SizeMin = &v
	}
	if filter.SizeMax != nil {
		v := int64(*filter.SizeMax)
		rf.SizeMax = &v
	}
	if filter.CreatedAfter != nil && *filter.CreatedAfter != "" {
		if t, err := time.Parse(time.RFC3339, *filter.CreatedAfter); err == nil {
			rf.CreatedAfter = &t
		}
	}
	if filter.CreatedBefore != nil && *filter.CreatedBefore != "" {
		if t, err := time.Parse(time.RFC3339, *filter.CreatedBefore); err == nil {
			rf.CreatedBefore = &t
		}
	}
	if len(filter.Tags) > 0 {
		rf.Tags = filter.Tags
	}
	if filter.UploaderName != nil && *filter.UploaderName != "" {
		rf.UploaderName = filter.UploaderName
	}

	pg := repository.Page{Limit: 50}
	if pagination != nil {
		if pagination.Limit != nil {
			pg.Limit = *pagination.Limit
		}
		pg.Cursor = pagination.Cursor
	}

	items, next, total, err := r.FileService.SearchUserFiles(ctx, userID, rf, pg)
	if err != nil {
		return nil, err
	}

	edges := []*model.UserFileEdge{}
	for _, uf := range items {
		var namePtr *string
		if uf.UploaderName != "" {
			n := uf.UploaderName
			namePtr = &n
		}
		var picPtr *string
		if uf.UploaderPicture != "" {
			p := uf.UploaderPicture
			picPtr = &p
		}
		edges = append(edges, &model.UserFileEdge{
			Cursor: fmt.Sprintf("%d:%s", uf.UploadedAt.UnixNano(), uf.ID.String()),
			Node: &model.UserFile{
				ID:         uf.ID.String(),
				UserID:     uf.UserID.String(),
				FileID:     uf.FileID.String(),
				UploadedAt: uf.UploadedAt.Format(time.RFC3339),
				File: &model.File{
					ID:           uf.File.ID.String(),
					Hash:         uf.File.Hash,
					OriginalName: uf.File.OriginalName,
					MimeType:     uf.File.MimeType,
					Size:         int(uf.File.Size),
					RefCount:     uf.File.RefCount,
					Visibility:   uf.File.Visibility,
					CreatedAt:    uf.File.CreatedAt.Format(time.RFC3339),
				},
				Uploader: &model.Uploader{
					Email:   uf.UploaderEmail,
					Name:    namePtr,
					Picture: picPtr,
				},
			},
		})
	}

	return &model.UserFileConnection{
		Edges: edges,
		PageInfo: &model.PageInfo{
			EndCursor:   next,
			HasNextPage: next != nil,
		},
		TotalCount: total,
	}, nil
}

// MyFolders is the resolver for the myFolders field.
func (r *queryResolver) MyFolders(ctx context.Context, parentID *string) ([]*model.Folder, error) {
	userIDStr, ok := middleware.GetUserIDFromContext(ctx)
	if !ok {
		return nil, fmt.Errorf("unauthorized")
	}
	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user id in token")
	}
	if r.FolderService == nil {
		return nil, fmt.Errorf("folder service not configured")
	}
	var pid *uuid.UUID
	if parentID != nil && *parentID != "" {
		id, err := uuid.Parse(*parentID)
		if err != nil {
			return nil, fmt.Errorf("invalid parent id")
		}
		pid = &id
	}
	folders, err := r.FolderService.Repo.ListFolders(ctx, userID, pid)
	if err != nil {
		return nil, err
	}
	var out []*model.Folder
	for _, f := range folders {
		var pStr *string
		if f.ParentID != nil {
			s := f.ParentID.String()
			pStr = &s
		}
		out = append(out, &model.Folder{ID: f.ID.String(), Name: f.Name, ParentID: pStr, CreatedAt: f.CreatedAt.Format(time.RFC3339)})
	}
	return out, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
